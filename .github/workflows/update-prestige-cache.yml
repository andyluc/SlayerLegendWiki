name: Update Contributor Prestige Cache

# This workflow automatically updates the contributor prestige cache
# by fetching contributor statistics and calculating prestige tiers.
# This prevents every page load from hitting the GitHub API for prestige data.
#
# The cache is stored in a GitHub issue with the label "prestige-cache"
# and is read by PrestigeAvatar components throughout the wiki.
#
# Schedule: Runs daily at 3 AM UTC (offset from highscore to avoid conflicts)
# Manual: Can be triggered manually via GitHub UI (Actions tab)
on:
  schedule:
    - cron: '0 3 * * *'  # Daily at 3 AM UTC
  workflow_dispatch:  # Allow manual trigger from Actions tab

jobs:
  update-cache:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      issues: write  # Need write permission to update cache issue

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update prestige cache
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const CACHE_ISSUE_TITLE = '[Cache] Contributor Prestige';

            console.log('üîç Fetching contributor statistics...');

            // Fetch all contributors (paginated to get all of them)
            let allContributors = [];
            let page = 1;
            let hasMore = true;

            while (hasMore) {
              const { data: contributors } = await github.rest.repos.listContributors({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100,
                page: page
              });

              allContributors = allContributors.concat(contributors);

              if (contributors.length < 100) {
                hasMore = false;
              } else {
                page++;
              }
            }

            console.log(`‚úÖ Found ${allContributors.length} total contributors`);

            // Filter out bots (usernames ending in [bot] or type = 'Bot')
            const humanContributors = allContributors.filter(contributor => {
              const isBot = contributor.login.endsWith('[bot]') ||
                            contributor.type === 'Bot' ||
                            contributor.login.toLowerCase().includes('bot');
              return !isBot;
            });

            console.log(`‚úÖ Filtered to ${humanContributors.length} human contributors (excluded ${allContributors.length - humanContributors.length} bots)`);

            // Calculate prestige tier for each contributor
            // Prestige tiers from wiki-config.json
            const prestigeTiers = [
              { id: 'legend', minContributions: 100, badge: 'üëë', color: '#dc2626' },
              { id: 'master', minContributions: 50, badge: 'üèÜ', color: '#f97316' },
              { id: 'expert', minContributions: 30, badge: '‚≠ê', color: '#f59e0b' },
              { id: 'dedicated', minContributions: 15, badge: 'üìö', color: '#8b5cf6' },
              { id: 'regular', minContributions: 5, badge: 'üìù', color: '#10b981' },
              { id: 'contributor', minContributions: 1, badge: '‚úçÔ∏è', color: '#3b82f6' },
              { id: 'newcomer', minContributions: 0, badge: 'üå±', color: '#9ca3af' }
            ];

            function calculatePrestigeTier(contributions) {
              for (const tier of prestigeTiers) {
                if (contributions >= tier.minContributions) {
                  return tier;
                }
              }
              return prestigeTiers[prestigeTiers.length - 1]; // Default to newcomer
            }

            // Build prestige data map
            const prestigeData = {};
            for (const contributor of humanContributors) {
              const tier = calculatePrestigeTier(contributor.contributions);
              prestigeData[contributor.login] = {
                login: contributor.login,
                contributions: contributor.contributions,
                prestigeTier: tier.id,
                prestigeBadge: tier.badge,
                prestigeColor: tier.color,
                avatarUrl: contributor.avatar_url,
                profileUrl: contributor.html_url
              };
            }

            console.log('üìä Prestige breakdown:');
            const tierCounts = {};
            for (const tier of prestigeTiers) {
              tierCounts[tier.id] = 0;
            }
            for (const data of Object.values(prestigeData)) {
              tierCounts[data.prestigeTier]++;
            }
            for (const tier of prestigeTiers) {
              console.log(`   ${tier.badge} ${tier.id}: ${tierCounts[tier.id]} contributors`);
            }

            // Create cache data
            const cacheData = {
              lastUpdated: new Date().toISOString(),
              totalContributors: humanContributors.length,
              prestigeData: prestigeData
            };

            console.log('üîç Looking for prestige cache issue...');

            // Find existing cache issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'prestige-cache',
              per_page: 1
            });

            let issueNumber;

            if (issues.length > 0) {
              // Update existing issue
              issueNumber = issues[0].number;
              console.log(`üìù Updating existing prestige cache issue #${issueNumber}...`);

              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: JSON.stringify(cacheData, null, 2)
              });
            } else {
              // Create new issue
              console.log('üìù Creating new prestige cache issue...');

              const { data: newIssue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: CACHE_ISSUE_TITLE,
                body: JSON.stringify(cacheData, null, 2),
                labels: ['prestige-cache', 'automation']
              });

              issueNumber = newIssue.number;
            }

            console.log(`‚úÖ Prestige cache updated successfully!`);
            console.log(`   Issue: #${issueNumber}`);
            console.log(`   Contributors: ${humanContributors.length}`);
            console.log(`   Top prestige users: ${Object.values(prestigeData).filter(d => d.prestigeTier === 'legend').map(d => d.login).slice(0, 5).join(', ') || 'None yet'}`);
