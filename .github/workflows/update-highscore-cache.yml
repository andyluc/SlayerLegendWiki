name: Update Contributor Highscore Cache

# This workflow automatically updates the contributor highscore cache
# by fetching fresh contributor statistics and storing them in a GitHub issue.
# This prevents every user from hitting the GitHub API for the same data.
#
# The cache is stored in a GitHub issue with the label "highscore-cache"
# and is read by the wiki's highscore page for all users.
#
# Cache Structure:
# - All Time: Total contributions from repos.listContributors()
# - This Month: Commits from the last 30 days
# - This Week: Commits from the last 7 days
#
# All contributor data includes userId for username-change immunity
#
# Schedule: Runs daily at 2 AM UTC
# Manual: Can be triggered manually via GitHub UI (Actions tab)
on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC
  workflow_dispatch:  # Allow manual trigger from Actions tab

jobs:
  update-cache:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      issues: write  # Need write permission to update cache issue

    env:
      WIKI_BOT_USERNAME: slayer-wiki-bot  # Bot service account username (anonymous contributions)

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update highscore cache
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const crypto = require('crypto');

            const CACHE_ISSUE_TITLE = '[Cache] Contributor Highscore';
            const BOT_USERNAME = process.env.WIKI_BOT_USERNAME || 'slayer-wiki-bot';

            // Read wiki config to get the configured branch and release date
            let configuredBranch = 'main'; // default
            let releaseDate = null; // null = no filtering
            try {
              const configPath = path.join(process.env.GITHUB_WORKSPACE, 'wiki-config.json');
              const configContent = fs.readFileSync(configPath, 'utf8');
              const config = JSON.parse(configContent);
              configuredBranch = config?.wiki?.repository?.branch || 'main';

              // Read release date from config
              const releaseDateStr = config?.wiki?.repository?.releaseDate;
              if (releaseDateStr && releaseDateStr.trim() !== '') {
                releaseDate = new Date(releaseDateStr);
                if (isNaN(releaseDate.getTime())) {
                  console.warn('âš ï¸ Invalid releaseDate in wiki-config.json:', releaseDateStr);
                  releaseDate = null;
                } else {
                  console.log(`ðŸ“… Release date configured: ${releaseDate.toISOString()}`);
                  console.log(`   Only activity after this date will be counted`);
                }
              }

              console.log(`ðŸ“‹ Using configured branch from wiki-config.json: ${configuredBranch}`);
            } catch (error) {
              console.warn('âš ï¸ Failed to read wiki-config.json, using default branch: main');
            }

            /**
             * Filter commits by release date
             * @param {Array} commits - Array of commits to filter
             * @returns {Array} Filtered commits after release date
             */
            function filterByReleaseDate(commits) {
              if (!releaseDate) return commits;

              const beforeCount = commits.length;
              const filtered = commits.filter(commit => {
                const commitDate = new Date(commit.commit.author.date);
                return commitDate >= releaseDate;
              });

              const filteredCount = beforeCount - filtered.length;
              if (filteredCount > 0) {
                console.log(`   ðŸ“… Filtered out ${filteredCount} commit(s) before release date`);
              }

              return filtered;
            }

            console.log('ðŸ” Fetching contributor statistics for all time periods...');

            /**
             * Calculate a fair contributor score that prevents gaming
             * Formula: (contributions * 100) + (quality_bonus * 2)
             *
             * - Base score from contributions (heavily weighted at 100x)
             * - Quality bonus from average lines per contribution (2x weight)
             * - This rewards both volume AND quality, preventing spam contributions
             */
            function calculateContributorScore(contributor) {
              const contributions = contributor.contributions || 0;
              const additions = contributor.additions || 0;
              const deletions = contributor.deletions || 0;

              // Base score: contributions heavily weighted
              const baseScore = contributions * 100;

              // Quality bonus: average lines changed per contribution
              // High value = meaningful contributions, Low value = spam
              const totalLines = additions + deletions;
              const averageLinesPerContribution = contributions > 0 ? totalLines / contributions : 0;
              const qualityBonus = averageLinesPerContribution * 2;

              // Final score
              const score = baseScore + qualityBonus;

              return Math.round(score);
            }

            /**
             * Hash email for privacy (consistent hashing for aggregation)
             */
            function hashEmail(email) {
              return crypto.createHash('sha256').update(email.toLowerCase().trim()).digest('hex');
            }

            /**
             * Parse anonymous contribution from bot commit message
             * Returns { name, email, verified } or null if not anonymous/verified
             */
            function parseAnonymousContribution(commitMessage) {
              // Check for verified anonymous contribution
              const nameMatch = commitMessage.match(/Anonymous contribution by:\s*(.+)/);
              const emailMatch = commitMessage.match(/Email:\s*(.+?)\s*\(verified\s*âœ“\)/);

              if (nameMatch && emailMatch) {
                return {
                  name: nameMatch[1].trim(),
                  email: emailMatch[1].trim(),
                  verified: true
                };
              }

              return null;
            }

            /**
             * Fetch all-time contributor stats
             * Enhanced with PR data for additions/deletions
             */
            async function fetchAllTimeContributors() {
              console.log('ðŸ“Š Fetching all-time contributors...');

              // Get base contributor counts
              const { data: contributors } = await github.rest.repos.listContributors({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });

              console.log(`âœ… Found ${contributors.length} all-time contributors`);

              // Create map with base stats (exclude bot)
              const contributorMap = new Map();
              const anonymousMap = new Map(); // Anonymous contributors keyed by hashed email

              contributors.forEach(contributor => {
                // Skip bot account - its contributions will be attributed to anonymous users
                if (contributor.login === BOT_USERNAME) {
                  console.log(`   â­ï¸  Skipping bot account: ${BOT_USERNAME} (will process as anonymous)`);
                  return;
                }

                contributorMap.set(contributor.id, {
                  userId: contributor.id,
                  login: contributor.login,
                  avatarUrl: contributor.avatar_url,
                  contributions: contributor.contributions,
                  additions: 0,
                  deletions: 0,
                  profileUrl: contributor.html_url,
                  prestige: 0,
                  type: contributor.type
                });
              });

              // Enhance with commit data to get additions/deletions
              console.log('ðŸ“Š Fetching all commits for additions/deletions data...');

              let page = 1;
              const perPage = 100;
              let hasMore = true;

              while (hasMore) {
                const { data: commits } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: configuredBranch,
                  per_page: perPage,
                  page: page,
                });

                if (commits.length === 0) break;

                // Filter by release date
                const filteredCommits = filterByReleaseDate(commits);

                console.log(`   Page ${page}: Processing ${filteredCommits.length} commits...`);

                // Fetch detailed commit data to get additions/deletions
                for (const commit of filteredCommits) {
                  const author = commit.author || commit.commit.author;
                  const userId = author?.id;
                  const login = author?.login;

                  try {
                    // repos.listCommits() doesn't include additions/deletions, need repos.getCommit()
                    const { data: detailedCommit } = await github.rest.repos.getCommit({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: commit.sha,
                    });

                    const stats = detailedCommit.stats || {};
                    const additions = stats.additions || 0;
                    const deletions = stats.deletions || 0;

                    // Check if this is a bot commit (anonymous contribution)
                    if (login === BOT_USERNAME) {
                      const anonData = parseAnonymousContribution(detailedCommit.commit.message);
                      if (anonData && anonData.verified) {
                        const emailHash = hashEmail(anonData.email);

                        if (anonymousMap.has(emailHash)) {
                          const anon = anonymousMap.get(emailHash);
                          anon.contributions++;
                          anon.additions += additions;
                          anon.deletions += deletions;
                        } else {
                          anonymousMap.set(emailHash, {
                            userId: null,
                            login: anonData.name, // Display name from contribution
                            avatarUrl: null,
                            contributions: 1,
                            additions,
                            deletions,
                            profileUrl: null,
                            prestige: 0,
                            type: 'Anonymous',
                            isAnonymous: true,
                            emailHash: emailHash
                          });
                        }
                      }
                    } else if (userId && contributorMap.has(userId)) {
                      // Regular contributor
                      const contributor = contributorMap.get(userId);
                      contributor.additions += additions;
                      contributor.deletions += deletions;
                    }
                  } catch (error) {
                    console.warn(`   âš ï¸ Failed to fetch details for commit ${commit.sha.substring(0, 7)}:`, error.message);
                  }
                }

                hasMore = commits.length === perPage;
                page++;

                // Safety limit to prevent excessive API calls
                if (page > 50) {
                  console.warn('âš ï¸ Reached page limit (50) for commit fetching');
                  break;
                }
              }

              // Merge regular contributors and anonymous contributors
              const allContributors = [
                ...Array.from(contributorMap.values()),
                ...Array.from(anonymousMap.values())
              ];

              // Calculate scores for all contributors
              const formatted = allContributors.map(contributor => {
                contributor.score = calculateContributorScore(contributor);
                return contributor;
              });

              // Sort by score (descending), fallback to contributions if equal
              formatted.sort((a, b) => {
                if (b.score !== a.score) {
                  return b.score - a.score;
                }
                return b.contributions - a.contributions;
              });

              console.log(`âœ… Enhanced ${contributorMap.size} registered + ${anonymousMap.size} anonymous contributors`);
              console.log(`   Total: ${formatted.length} contributors`);

              return formatted;
            }

            /**
             * Fetch commits within a date range with detailed additions/deletions by author
             * This gives credit to all contributions, whether through PRs or direct commits
             */
            async function fetchCommitsWithStatsInDateRange(since, until, branch = 'main') {
              console.log(`ðŸ“Š Fetching commits from ${since} to ${until} on branch '${branch}'...`);

              const commits = [];
              let page = 1;
              const perPage = 100;

              // Fetch all commits in date range
              while (true) {
                const { data } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: branch, // Explicitly specify branch
                  since,
                  until,
                  per_page: perPage,
                  page: page,
                });

                if (data.length === 0) break;
                commits.push(...data);

                // If we got fewer than perPage, we've reached the end
                if (data.length < perPage) break;
                page++;
              }

              console.log(`âœ… Found ${commits.length} commits in date range`);

              // Filter by release date
              const filteredCommits = filterByReleaseDate(commits);
              console.log(`   After release date filter: ${filteredCommits.length} commits`);

              // Aggregate commits by author (use user ID as key for permanent identification)
              const contributorMap = new Map();
              const anonymousMap = new Map(); // Anonymous contributors keyed by hashed email

              // Fetch detailed commit data to get additions/deletions
              console.log(`   Fetching detailed stats for ${filteredCommits.length} commits...`);
              for (const commit of filteredCommits) {
                const author = commit.author || commit.commit.author;
                const login = author?.login;
                const userId = author?.id;

                // Skip commits without a GitHub user (e.g., local git commits)
                if (!login) continue;

                // Skip bot account - will be processed as anonymous
                if (login === BOT_USERNAME) {
                  // Will be handled below
                } else {
                  // Continue with normal processing for non-bot users
                }

                try {
                  // repos.listCommits() doesn't include additions/deletions, need repos.getCommit()
                  const { data: detailedCommit } = await github.rest.repos.getCommit({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: commit.sha,
                  });

                  // Calculate stats from commit
                  const stats = detailedCommit.stats || {};
                  const additions = stats.additions || 0;
                  const deletions = stats.deletions || 0;

                  // Check if this is a bot commit (anonymous contribution)
                  if (login === BOT_USERNAME) {
                    const anonData = parseAnonymousContribution(detailedCommit.commit.message);
                    if (anonData && anonData.verified) {
                      const emailHash = hashEmail(anonData.email);

                      if (anonymousMap.has(emailHash)) {
                        const anon = anonymousMap.get(emailHash);
                        anon.contributions++;
                        anon.additions += additions;
                        anon.deletions += deletions;
                      } else {
                        anonymousMap.set(emailHash, {
                          userId: null,
                          login: anonData.name, // Display name from contribution
                          avatarUrl: null,
                          contributions: 1,
                          additions,
                          deletions,
                          profileUrl: null,
                          prestige: 0,
                          type: 'Anonymous',
                          isAnonymous: true,
                          emailHash: emailHash
                        });
                      }
                    }
                  } else {
                    // Regular contributor
                    // Use user ID as key (permanent), fallback to login
                    const key = userId ? userId.toString() : `legacy:${login}`;

                    if (contributorMap.has(key)) {
                      const existing = contributorMap.get(key);
                      existing.contributions++;
                      existing.additions += additions;
                      existing.deletions += deletions;
                      // Update login in case username changed
                      existing.login = login;
                    } else {
                      contributorMap.set(key, {
                        userId: userId || null,
                        login: login,
                        avatarUrl: author.avatar_url,
                        contributions: 1,
                        additions,
                        deletions,
                        profileUrl: author.html_url,
                        prestige: 0,
                        type: author.type || 'User',
                      });
                    }
                  }
                } catch (error) {
                  console.warn(`âš ï¸ Failed to fetch details for commit ${commit.sha.substring(0, 7)}:`, error.message);
                }
              }

              // Merge regular contributors and anonymous contributors
              const allContributors = [
                ...Array.from(contributorMap.values()),
                ...Array.from(anonymousMap.values())
              ];

              // Calculate scores for all contributors
              const contributors = allContributors.map(contributor => {
                contributor.score = calculateContributorScore(contributor);
                return contributor;
              });

              // Sort by score (descending), fallback to contributions if equal
              contributors.sort((a, b) => {
                if (b.score !== a.score) {
                  return b.score - a.score;
                }
                return b.contributions - a.contributions;
              });

              console.log(`âœ… Found ${contributorMap.size} registered + ${anonymousMap.size} anonymous contributors`);
              console.log(`   Total: ${contributors.length} contributors`);
              return contributors;
            }

            /**
             * Fetch commits within a date range and aggregate by author
             * @deprecated Use fetchCommitsWithStatsInDateRange for accurate additions/deletions
             */
            async function fetchCommitsInDateRange(since, until, branch = 'main') {
              console.log(`ðŸ“Š Fetching commits from ${since} to ${until} on branch '${branch}'...`);

              const commits = [];
              let page = 1;
              const perPage = 100;

              // Fetch all commits in date range (with pagination)
              // Use sha parameter to explicitly specify the branch
              while (true) {
                const { data } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: branch, // Explicitly specify branch to only count main branch commits
                  since,
                  until,
                  per_page: perPage,
                  page: page,
                });

                if (data.length === 0) break;
                commits.push(...data);

                // If we got fewer than perPage, we've reached the end
                if (data.length < perPage) break;
                page++;
              }

              console.log(`âœ… Found ${commits.length} commits in date range`);

              // Aggregate commits by author (use user ID as key for permanent identification)
              const contributorMap = new Map();

              for (const commit of commits) {
                const author = commit.author || commit.commit.author;
                const login = author?.login;
                const userId = author?.id;

                // Skip commits without a GitHub user (e.g., local git commits)
                if (!login) continue;

                // Use user ID as key (permanent), fallback to login for local commits
                const key = userId ? userId.toString() : `legacy:${login}`;

                if (contributorMap.has(key)) {
                  contributorMap.get(key).contributions++;
                  // Update login in case username changed
                  contributorMap.get(key).login = login;
                } else {
                  contributorMap.set(key, {
                    userId: userId || null,
                    login: login,
                    avatarUrl: author.avatar_url,
                    contributions: 1,
                    additions: 0, // Note: commit data doesn't include line changes
                    deletions: 0, // Note: commit data doesn't include line changes
                    profileUrl: author.html_url,
                    prestige: 0,
                    type: author.type || 'User',
                  });
                }
              }

              // Convert map to array and calculate scores
              const contributors = Array.from(contributorMap.values()).map(contributor => ({
                ...contributor,
                score: calculateContributorScore(contributor),
              }));

              // Sort by score (descending), fallback to contributions if equal
              contributors.sort((a, b) => {
                if (b.score !== a.score) {
                  return b.score - a.score;
                }
                return b.contributions - a.contributions;
              });

              console.log(`âœ… Found ${contributors.length} unique contributors in date range`);
              return contributors;
            }

            // Calculate date ranges
            const now = new Date();
            const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

            // Fetch all three categories in parallel (using commit data for accurate stats)
            console.log(`ðŸ”„ Fetching contributor data from branch: ${configuredBranch}`);
            const [allTimeContributors, thisMonthContributors, thisWeekContributors] = await Promise.all([
              fetchAllTimeContributors(),
              fetchCommitsWithStatsInDateRange(oneMonthAgo.toISOString(), now.toISOString(), configuredBranch),
              fetchCommitsWithStatsInDateRange(oneWeekAgo.toISOString(), now.toISOString(), configuredBranch),
            ]);

            // Create cache data with all categories
            const cacheData = {
              lastUpdated: now.toISOString(),
              categories: {
                allTime: {
                  contributors: allTimeContributors,
                },
                thisMonth: {
                  startDate: oneMonthAgo.toISOString(),
                  endDate: now.toISOString(),
                  contributors: thisMonthContributors,
                },
                thisWeek: {
                  startDate: oneWeekAgo.toISOString(),
                  endDate: now.toISOString(),
                  contributors: thisWeekContributors,
                },
              },
            };

            console.log('ðŸ” Looking for cache issue...');

            // Find existing cache issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'highscore-cache',
              per_page: 100
            });

            // Find issue with exact title match
            const existingIssue = issues.find(issue => issue.title === CACHE_ISSUE_TITLE);

            let issueNumber;

            if (existingIssue) {
              // Update existing issue
              issueNumber = existingIssue.number;
              console.log(`ðŸ“ Updating existing cache issue #${issueNumber}...`);

              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: JSON.stringify(cacheData, null, 2)
              });
            } else {
              // Create new issue
              console.log('ðŸ“ Creating new cache issue...');

              const { data: newIssue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: CACHE_ISSUE_TITLE,
                body: JSON.stringify(cacheData, null, 2),
                labels: ['highscore-cache', 'automated']
              });

              issueNumber = newIssue.number;

              // Lock the issue to prevent unwanted comments
              try {
                await github.rest.issues.lock({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  lock_reason: 'off-topic'
                });
                console.log('ðŸ”’ Locked cache issue to collaborators only');
              } catch (lockError) {
                console.warn('âš ï¸ Failed to lock issue:', lockError.message);
              }
            }

            console.log(`âœ… Cache updated successfully!`);
            console.log(`   Issue: #${issueNumber}`);
            console.log(`   Last Updated: ${cacheData.lastUpdated}`);
            console.log('');
            console.log('ðŸ“Š Category Statistics:');
            console.log(`   All Time: ${allTimeContributors.length} contributors`);
            console.log(`   This Month: ${thisMonthContributors.length} contributors`);
            console.log(`   This Week: ${thisWeekContributors.length} contributors`);
            console.log('');
            console.log(`ðŸ† Top 3 All Time: ${allTimeContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            if (thisMonthContributors.length > 0) {
              console.log(`ðŸ”¥ Top 3 This Month: ${thisMonthContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            }
            if (thisWeekContributors.length > 0) {
              console.log(`âš¡ Top 3 This Week: ${thisWeekContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            }
