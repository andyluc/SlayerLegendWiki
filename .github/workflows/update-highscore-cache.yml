name: Update Contributor Highscore Cache

# This workflow automatically updates the contributor highscore cache
# by fetching fresh contributor statistics and storing them in a GitHub issue.
# This prevents every user from hitting the GitHub API for the same data.
#
# The cache is stored in a GitHub issue with the label "highscore-cache"
# and is read by the wiki's highscore page for all users.
#
# Cache Structure:
# - All Time: Total contributions from repos.listContributors()
# - This Month: Commits from the last 30 days
# - This Week: Commits from the last 7 days
#
# All contributor data includes userId for username-change immunity
#
# Schedule: Runs daily at 2 AM UTC
# Manual: Can be triggered manually via GitHub UI (Actions tab)
on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC
  workflow_dispatch:  # Allow manual trigger from Actions tab

jobs:
  update-cache:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      issues: write  # Need write permission to update cache issue

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update highscore cache
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const CACHE_ISSUE_TITLE = '[Cache] Contributor Highscore';

            // Read wiki config to get the configured branch
            let configuredBranch = 'main'; // default
            try {
              const configPath = path.join(process.env.GITHUB_WORKSPACE, 'wiki-config.json');
              const configContent = fs.readFileSync(configPath, 'utf8');
              const config = JSON.parse(configContent);
              configuredBranch = config?.wiki?.repository?.branch || 'main';
              console.log(`ðŸ“‹ Using configured branch from wiki-config.json: ${configuredBranch}`);
            } catch (error) {
              console.warn('âš ï¸ Failed to read wiki-config.json, using default branch: main');
            }

            console.log('ðŸ” Fetching contributor statistics for all time periods...');

            /**
             * Calculate a fair contributor score that prevents gaming
             * Formula: (contributions * 100) + (quality_bonus * 2)
             *
             * - Base score from contributions (heavily weighted at 100x)
             * - Quality bonus from average lines per contribution (2x weight)
             * - This rewards both volume AND quality, preventing spam contributions
             */
            function calculateContributorScore(contributor) {
              const contributions = contributor.contributions || 0;
              const additions = contributor.additions || 0;
              const deletions = contributor.deletions || 0;

              // Base score: contributions heavily weighted
              const baseScore = contributions * 100;

              // Quality bonus: average lines changed per contribution
              // High value = meaningful contributions, Low value = spam
              const totalLines = additions + deletions;
              const averageLinesPerContribution = contributions > 0 ? totalLines / contributions : 0;
              const qualityBonus = averageLinesPerContribution * 2;

              // Final score
              const score = baseScore + qualityBonus;

              return Math.round(score);
            }

            /**
             * Fetch all-time contributor stats
             * Enhanced with PR data for additions/deletions
             */
            async function fetchAllTimeContributors() {
              console.log('ðŸ“Š Fetching all-time contributors...');

              // Get base contributor counts
              const { data: contributors } = await github.rest.repos.listContributors({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });

              console.log(`âœ… Found ${contributors.length} all-time contributors`);

              // Create map with base stats
              const contributorMap = new Map();
              contributors.forEach(contributor => {
                contributorMap.set(contributor.id, {
                  userId: contributor.id,
                  login: contributor.login,
                  avatarUrl: contributor.avatar_url,
                  contributions: contributor.contributions,
                  additions: 0,
                  deletions: 0,
                  profileUrl: contributor.html_url,
                  prestige: 0,
                  type: contributor.type
                });
              });

              // Enhance with commit data to get additions/deletions
              console.log('ðŸ“Š Fetching all commits for additions/deletions data...');

              let page = 1;
              const perPage = 100;
              let hasMore = true;

              while (hasMore) {
                const { data: commits } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: configuredBranch,
                  per_page: perPage,
                  page: page,
                });

                if (commits.length === 0) break;

                console.log(`   Page ${page}: Processing ${commits.length} commits...`);

                // Fetch detailed commit data to get additions/deletions
                for (const commit of commits) {
                  const author = commit.author || commit.commit.author;
                  const userId = author?.id;

                  if (userId && contributorMap.has(userId)) {
                    try {
                      // repos.listCommits() doesn't include additions/deletions, need repos.getCommit()
                      const { data: detailedCommit } = await github.rest.repos.getCommit({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        ref: commit.sha,
                      });

                      const stats = detailedCommit.stats || {};
                      const contributor = contributorMap.get(userId);
                      contributor.additions += stats.additions || 0;
                      contributor.deletions += stats.deletions || 0;
                    } catch (error) {
                      console.warn(`   âš ï¸ Failed to fetch details for commit ${commit.sha.substring(0, 7)}:`, error.message);
                    }
                  }
                }

                hasMore = commits.length === perPage;
                page++;

                // Safety limit to prevent excessive API calls
                if (page > 50) {
                  console.warn('âš ï¸ Reached page limit (50) for commit fetching');
                  break;
                }
              }

              // Convert to array and calculate scores
              const formatted = Array.from(contributorMap.values()).map(contributor => {
                contributor.score = calculateContributorScore(contributor);
                return contributor;
              });

              // Sort by score (descending), fallback to contributions if equal
              formatted.sort((a, b) => {
                if (b.score !== a.score) {
                  return b.score - a.score;
                }
                return b.contributions - a.contributions;
              });

              console.log(`âœ… Enhanced ${formatted.length} contributors with commit data`);

              return formatted;
            }

            /**
             * Fetch commits within a date range with detailed additions/deletions by author
             * This gives credit to all contributions, whether through PRs or direct commits
             */
            async function fetchCommitsWithStatsInDateRange(since, until, branch = 'main') {
              console.log(`ðŸ“Š Fetching commits from ${since} to ${until} on branch '${branch}'...`);

              const commits = [];
              let page = 1;
              const perPage = 100;

              // Fetch all commits in date range
              while (true) {
                const { data } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: branch, // Explicitly specify branch
                  since,
                  until,
                  per_page: perPage,
                  page: page,
                });

                if (data.length === 0) break;
                commits.push(...data);

                // If we got fewer than perPage, we've reached the end
                if (data.length < perPage) break;
                page++;
              }

              console.log(`âœ… Found ${commits.length} commits in date range`);

              // Aggregate commits by author (use user ID as key for permanent identification)
              const contributorMap = new Map();

              // Fetch detailed commit data to get additions/deletions
              console.log(`   Fetching detailed stats for ${commits.length} commits...`);
              for (const commit of commits) {
                const author = commit.author || commit.commit.author;
                const login = author?.login;
                const userId = author?.id;

                // Skip commits without a GitHub user (e.g., local git commits)
                if (!login) continue;

                try {
                  // repos.listCommits() doesn't include additions/deletions, need repos.getCommit()
                  const { data: detailedCommit } = await github.rest.repos.getCommit({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: commit.sha,
                  });

                  // Calculate stats from commit
                  const stats = detailedCommit.stats || {};
                  const additions = stats.additions || 0;
                  const deletions = stats.deletions || 0;

                  // Use user ID as key (permanent), fallback to login
                  const key = userId ? userId.toString() : `legacy:${login}`;

                  if (contributorMap.has(key)) {
                    const existing = contributorMap.get(key);
                    existing.contributions++;
                    existing.additions += additions;
                    existing.deletions += deletions;
                    // Update login in case username changed
                    existing.login = login;
                  } else {
                    contributorMap.set(key, {
                      userId: userId || null,
                      login: login,
                      avatarUrl: author.avatar_url,
                      contributions: 1,
                      additions,
                      deletions,
                      profileUrl: author.html_url,
                      prestige: 0,
                      type: author.type || 'User',
                    });
                  }
                } catch (error) {
                  console.warn(`âš ï¸ Failed to fetch details for commit ${commit.sha.substring(0, 7)}:`, error.message);
                }
              }

              // Convert to array and calculate scores
              const contributors = Array.from(contributorMap.values()).map(contributor => {
                contributor.score = calculateContributorScore(contributor);
                return contributor;
              });

              // Sort by score (descending), fallback to contributions if equal
              contributors.sort((a, b) => {
                if (b.score !== a.score) {
                  return b.score - a.score;
                }
                return b.contributions - a.contributions;
              });

              console.log(`âœ… Found ${contributors.length} unique contributors from commits`);
              return contributors;
            }

            /**
             * Fetch commits within a date range and aggregate by author
             * @deprecated Use fetchCommitsWithStatsInDateRange for accurate additions/deletions
             */
            async function fetchCommitsInDateRange(since, until, branch = 'main') {
              console.log(`ðŸ“Š Fetching commits from ${since} to ${until} on branch '${branch}'...`);

              const commits = [];
              let page = 1;
              const perPage = 100;

              // Fetch all commits in date range (with pagination)
              // Use sha parameter to explicitly specify the branch
              while (true) {
                const { data } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  sha: branch, // Explicitly specify branch to only count main branch commits
                  since,
                  until,
                  per_page: perPage,
                  page: page,
                });

                if (data.length === 0) break;
                commits.push(...data);

                // If we got fewer than perPage, we've reached the end
                if (data.length < perPage) break;
                page++;
              }

              console.log(`âœ… Found ${commits.length} commits in date range`);

              // Aggregate commits by author (use user ID as key for permanent identification)
              const contributorMap = new Map();

              for (const commit of commits) {
                const author = commit.author || commit.commit.author;
                const login = author?.login;
                const userId = author?.id;

                // Skip commits without a GitHub user (e.g., local git commits)
                if (!login) continue;

                // Use user ID as key (permanent), fallback to login for local commits
                const key = userId ? userId.toString() : `legacy:${login}`;

                if (contributorMap.has(key)) {
                  contributorMap.get(key).contributions++;
                  // Update login in case username changed
                  contributorMap.get(key).login = login;
                } else {
                  contributorMap.set(key, {
                    userId: userId || null,
                    login: login,
                    avatarUrl: author.avatar_url,
                    contributions: 1,
                    additions: 0, // Note: commit data doesn't include line changes
                    deletions: 0, // Note: commit data doesn't include line changes
                    profileUrl: author.html_url,
                    prestige: 0,
                    type: author.type || 'User',
                  });
                }
              }

              // Convert map to array and calculate scores
              const contributors = Array.from(contributorMap.values()).map(contributor => ({
                ...contributor,
                score: calculateContributorScore(contributor),
              }));

              // Sort by score (descending), fallback to contributions if equal
              contributors.sort((a, b) => {
                if (b.score !== a.score) {
                  return b.score - a.score;
                }
                return b.contributions - a.contributions;
              });

              console.log(`âœ… Found ${contributors.length} unique contributors in date range`);
              return contributors;
            }

            // Calculate date ranges
            const now = new Date();
            const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

            // Fetch all three categories in parallel (using commit data for accurate stats)
            console.log(`ðŸ”„ Fetching contributor data from branch: ${configuredBranch}`);
            const [allTimeContributors, thisMonthContributors, thisWeekContributors] = await Promise.all([
              fetchAllTimeContributors(),
              fetchCommitsWithStatsInDateRange(oneMonthAgo.toISOString(), now.toISOString(), configuredBranch),
              fetchCommitsWithStatsInDateRange(oneWeekAgo.toISOString(), now.toISOString(), configuredBranch),
            ]);

            // Create cache data with all categories
            const cacheData = {
              lastUpdated: now.toISOString(),
              categories: {
                allTime: {
                  contributors: allTimeContributors,
                },
                thisMonth: {
                  startDate: oneMonthAgo.toISOString(),
                  endDate: now.toISOString(),
                  contributors: thisMonthContributors,
                },
                thisWeek: {
                  startDate: oneWeekAgo.toISOString(),
                  endDate: now.toISOString(),
                  contributors: thisWeekContributors,
                },
              },
            };

            console.log('ðŸ” Looking for cache issue...');

            // Find existing cache issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'highscore-cache',
              per_page: 100
            });

            // Find issue with exact title match
            const existingIssue = issues.find(issue => issue.title === CACHE_ISSUE_TITLE);

            let issueNumber;

            if (existingIssue) {
              // Update existing issue
              issueNumber = existingIssue.number;
              console.log(`ðŸ“ Updating existing cache issue #${issueNumber}...`);

              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: JSON.stringify(cacheData, null, 2)
              });
            } else {
              // Create new issue
              console.log('ðŸ“ Creating new cache issue...');

              const { data: newIssue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: CACHE_ISSUE_TITLE,
                body: JSON.stringify(cacheData, null, 2),
                labels: ['highscore-cache', 'automated']
              });

              issueNumber = newIssue.number;

              // Lock the issue to prevent unwanted comments
              try {
                await github.rest.issues.lock({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  lock_reason: 'off-topic'
                });
                console.log('ðŸ”’ Locked cache issue to collaborators only');
              } catch (lockError) {
                console.warn('âš ï¸ Failed to lock issue:', lockError.message);
              }
            }

            console.log(`âœ… Cache updated successfully!`);
            console.log(`   Issue: #${issueNumber}`);
            console.log(`   Last Updated: ${cacheData.lastUpdated}`);
            console.log('');
            console.log('ðŸ“Š Category Statistics:');
            console.log(`   All Time: ${allTimeContributors.length} contributors`);
            console.log(`   This Month: ${thisMonthContributors.length} contributors`);
            console.log(`   This Week: ${thisWeekContributors.length} contributors`);
            console.log('');
            console.log(`ðŸ† Top 3 All Time: ${allTimeContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            if (thisMonthContributors.length > 0) {
              console.log(`ðŸ”¥ Top 3 This Month: ${thisMonthContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            }
            if (thisWeekContributors.length > 0) {
              console.log(`âš¡ Top 3 This Week: ${thisWeekContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            }
