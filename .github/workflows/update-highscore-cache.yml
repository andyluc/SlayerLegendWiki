name: Update Contributor Highscore Cache

# This workflow automatically updates the contributor highscore cache
# by fetching fresh contributor statistics and storing them in a GitHub issue.
# This prevents every user from hitting the GitHub API for the same data.
#
# The cache is stored in a GitHub issue with the label "highscore-cache"
# and is read by the wiki's highscore page for all users.
#
# Cache Structure:
# - All Time: Total contributions from repos.listContributors()
# - This Month: Commits from the last 30 days
# - This Week: Commits from the last 7 days
#
# All contributor data includes userId for username-change immunity
#
# Schedule: Runs daily at 2 AM UTC
# Manual: Can be triggered manually via GitHub UI (Actions tab)
on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC
  workflow_dispatch:  # Allow manual trigger from Actions tab

jobs:
  update-cache:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      issues: write  # Need write permission to update cache issue

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update highscore cache
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const CACHE_ISSUE_TITLE = '[Cache] Contributor Highscore';

            console.log('ðŸ” Fetching contributor statistics for all time periods...');

            /**
             * Fetch all-time contributor stats
             */
            async function fetchAllTimeContributors() {
              console.log('ðŸ“Š Fetching all-time contributors...');

              const { data: contributors } = await github.rest.repos.listContributors({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });

              console.log(`âœ… Found ${contributors.length} all-time contributors`);

              // Format contributor data with userId
              const formatted = contributors.map(contributor => ({
                userId: contributor.id,
                login: contributor.login,
                avatarUrl: contributor.avatar_url,
                contributions: contributor.contributions,
                profileUrl: contributor.html_url,
                prestige: 0,
                type: contributor.type
              }));

              // Sort by contributions (descending)
              formatted.sort((a, b) => b.contributions - a.contributions);

              return formatted;
            }

            /**
             * Fetch commits within a date range and aggregate by author
             */
            async function fetchCommitsInDateRange(since, until) {
              console.log(`ðŸ“Š Fetching commits from ${since} to ${until}...`);

              const commits = [];
              let page = 1;
              const perPage = 100;

              // Fetch all commits in date range (with pagination)
              while (true) {
                const { data } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  since,
                  until,
                  per_page: perPage,
                  page: page,
                });

                if (data.length === 0) break;
                commits.push(...data);

                // If we got fewer than perPage, we've reached the end
                if (data.length < perPage) break;
                page++;
              }

              console.log(`âœ… Found ${commits.length} commits in date range`);

              // Aggregate commits by author (use user ID as key for permanent identification)
              const contributorMap = new Map();

              for (const commit of commits) {
                const author = commit.author || commit.commit.author;
                const login = author?.login;
                const userId = author?.id;

                // Skip commits without a GitHub user (e.g., local git commits)
                if (!login) continue;

                // Use user ID as key (permanent), fallback to login for local commits
                const key = userId ? userId.toString() : `legacy:${login}`;

                if (contributorMap.has(key)) {
                  contributorMap.get(key).contributions++;
                  // Update login in case username changed
                  contributorMap.get(key).login = login;
                } else {
                  contributorMap.set(key, {
                    userId: userId || null,
                    login: login,
                    avatarUrl: author.avatar_url,
                    contributions: 1,
                    profileUrl: author.html_url,
                    prestige: 0,
                    type: author.type || 'User',
                  });
                }
              }

              // Convert map to array and sort by contributions
              const contributors = Array.from(contributorMap.values());
              contributors.sort((a, b) => b.contributions - a.contributions);

              console.log(`âœ… Found ${contributors.length} unique contributors in date range`);
              return contributors;
            }

            // Calculate date ranges
            const now = new Date();
            const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

            // Fetch all three categories in parallel
            const [allTimeContributors, thisMonthContributors, thisWeekContributors] = await Promise.all([
              fetchAllTimeContributors(),
              fetchCommitsInDateRange(oneMonthAgo.toISOString(), now.toISOString()),
              fetchCommitsInDateRange(oneWeekAgo.toISOString(), now.toISOString()),
            ]);

            // Create cache data with all categories
            const cacheData = {
              lastUpdated: now.toISOString(),
              categories: {
                allTime: {
                  contributors: allTimeContributors,
                },
                thisMonth: {
                  startDate: oneMonthAgo.toISOString(),
                  endDate: now.toISOString(),
                  contributors: thisMonthContributors,
                },
                thisWeek: {
                  startDate: oneWeekAgo.toISOString(),
                  endDate: now.toISOString(),
                  contributors: thisWeekContributors,
                },
              },
            };

            console.log('ðŸ” Looking for cache issue...');

            // Find existing cache issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'highscore-cache',
              per_page: 1
            });

            let issueNumber;

            if (issues.length > 0) {
              // Update existing issue
              issueNumber = issues[0].number;
              console.log(`ðŸ“ Updating existing cache issue #${issueNumber}...`);

              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: JSON.stringify(cacheData, null, 2)
              });
            } else {
              // Create new issue
              console.log('ðŸ“ Creating new cache issue...');

              const { data: newIssue } = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: CACHE_ISSUE_TITLE,
                body: JSON.stringify(cacheData, null, 2),
                labels: ['highscore-cache', 'automated']
              });

              issueNumber = newIssue.number;
            }

            console.log(`âœ… Cache updated successfully!`);
            console.log(`   Issue: #${issueNumber}`);
            console.log(`   Last Updated: ${cacheData.lastUpdated}`);
            console.log('');
            console.log('ðŸ“Š Category Statistics:');
            console.log(`   All Time: ${allTimeContributors.length} contributors`);
            console.log(`   This Month: ${thisMonthContributors.length} contributors`);
            console.log(`   This Week: ${thisWeekContributors.length} contributors`);
            console.log('');
            console.log(`ðŸ† Top 3 All Time: ${allTimeContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            if (thisMonthContributors.length > 0) {
              console.log(`ðŸ”¥ Top 3 This Month: ${thisMonthContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            }
            if (thisWeekContributors.length > 0) {
              console.log(`âš¡ Top 3 This Week: ${thisWeekContributors.slice(0, 3).map(c => `${c.login} (${c.contributions})`).join(', ')}`);
            }
