name: Cleanup Expired Email Verifications

on:
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch: # Allow manual trigger

jobs:
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read

    steps:
      - name: Cleanup expired verification comments
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            console.log(`[Cleanup] Starting expired verification cleanup for ${owner}/${repo}`);

            try {
              // Find the [Email Verification] issue
              const { data: issues } = await github.rest.issues.listForRepo({
                owner,
                repo,
                labels: 'email-verification',
                state: 'open',
                per_page: 10,
              });

              const verificationIssue = issues.find(issue => issue.title === '[Email Verification]');

              if (!verificationIssue) {
                console.log('[Cleanup] No email verification issue found');
                return;
              }

              console.log(`[Cleanup] Found verification issue #${verificationIssue.number}`);

              // Parse the index map from issue body
              let indexMap = {};
              try {
                const match = verificationIssue.body.match(/```json\n([\s\S]*?)\n```/);
                if (match) {
                  indexMap = JSON.parse(match[1]);
                  console.log(`[Cleanup] Loaded index map with ${Object.keys(indexMap).length} entries`);
                }
              } catch (parseError) {
                console.warn('[Cleanup] Failed to parse index map:', parseError.message);
              }

              // Get all comments on the issue
              const { data: comments } = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: verificationIssue.number,
                per_page: 100,
              });

              console.log(`[Cleanup] Found ${comments.length} total comments`);

              const now = Date.now();
              let deletedCount = 0;
              let skippedCount = 0;
              let errorCount = 0;
              const deletedEmailHashes = [];

              // Check each comment for expiration
              for (const comment of comments) {
                try {
                  // Try to parse comment as verification data
                  const data = JSON.parse(comment.body);

                  // Check if it has the expected structure
                  if (data.emailHash && data.code && data.expiresAt) {
                    // Check if expired
                    if (now > data.expiresAt) {
                      // Delete expired comment
                      await github.rest.issues.deleteComment({
                        owner,
                        repo,
                        comment_id: comment.id,
                      });

                      // Track deleted email hash for index update
                      deletedEmailHashes.push(data.emailHash);

                      const ageMinutes = Math.round((now - data.expiresAt) / 1000 / 60);
                      console.log(`[Cleanup] Deleted expired comment #${comment.id} (expired ${ageMinutes} minutes ago)`);
                      deletedCount++;
                    } else {
                      const remainingMinutes = Math.round((data.expiresAt - now) / 1000 / 60);
                      console.log(`[Cleanup] Skipping valid comment #${comment.id} (expires in ${remainingMinutes} minutes)`);
                      skippedCount++;
                    }
                  } else {
                    console.log(`[Cleanup] Skipping malformed comment #${comment.id}`);
                    skippedCount++;
                  }
                } catch (parseError) {
                  // Not a valid JSON comment, skip it
                  console.log(`[Cleanup] Skipping non-JSON comment #${comment.id}`);
                  skippedCount++;
                } catch (deleteError) {
                  console.error(`[Cleanup] Failed to delete comment #${comment.id}:`, deleteError.message);
                  errorCount++;
                }
              }

              // Update index map by removing deleted entries
              if (deletedEmailHashes.length > 0) {
                for (const emailHash of deletedEmailHashes) {
                  delete indexMap[emailHash];
                }

                // Update issue body with new index
                try {
                  const updatedBody = verificationIssue.body.replace(
                    /```json\n[\s\S]*?\n```/,
                    `\`\`\`json\n${JSON.stringify(indexMap, null, 2)}\n\`\`\``
                  );

                  await github.rest.issues.update({
                    owner,
                    repo,
                    issue_number: verificationIssue.number,
                    body: updatedBody,
                  });

                  console.log(`[Cleanup] Updated index map (removed ${deletedEmailHashes.length} entries)`);
                } catch (updateError) {
                  console.error('[Cleanup] Failed to update index map:', updateError.message);
                }
              }

              console.log(`[Cleanup] Cleanup complete:`);
              console.log(`  - Deleted: ${deletedCount} expired comments`);
              console.log(`  - Skipped: ${skippedCount} valid/malformed comments`);
              console.log(`  - Errors: ${errorCount} failed deletions`);

              // Post summary comment (optional - only if cleanup happened)
              if (deletedCount > 0) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: verificationIssue.number,
                  body: `ðŸ¤– **Automated Cleanup**\n\nDeleted ${deletedCount} expired verification code(s).\n\n*Cleanup run: ${new Date().toISOString()}*`,
                });
              }
            } catch (error) {
              console.error('[Cleanup] Cleanup failed:', error);
              core.setFailed(`Cleanup failed: ${error.message}`);
            }
